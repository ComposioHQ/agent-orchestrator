# Agent Rules — Reboot Dashboard

## Linear Label Management (MANDATORY)

You MUST update Linear labels at each milestone. Use the Linear MCP tools available in your session to manage labels on your assigned issue. If MCP tools are unavailable, fall back to the CLI method shown below.

### Label Lifecycle

Update labels at these exact points — no exceptions:

| When | Labels: Remove | Labels: Add | Move Issue To |
|------|---------------|-------------|---------------|
| You start working | `agent-ready`, `needs-spec` | `agent-working` | **In Progress** |
| You open a PR | — | — | **In Review** |
| CI fails on your PR | — | `ci-failed` | — |
| You fix CI and it passes | `ci-failed` | — | — |
| Orchestrator tells you PR is approved+green | `agent-working` | — | **In QA** |
| Orchestrator sends merge instruction | — | — | **Done** (after merge) |
| You need hardware for QA | — | `hardware` | — |
| You get stuck or blocked | `agent-working` | — | — |

### How to Update Labels

**Via Linear MCP (preferred):**
If you have Linear MCP tools, use them to update the issue directly. Look for tools like `linear_update_issue` or `linear_add_label`.

**Via CLI fallback:**
```bash
# Get your Linear API key from environment
# Add a label
curl -s -X POST https://api.linear.app/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: ${LINEAR_API_KEY}" \
  -d '{"query":"mutation { issueAddLabel(id: \"ISSUE_UUID\", labelId: \"LABEL_UUID\") { success } }"}'

# Remove a label
curl -s -X POST https://api.linear.app/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: ${LINEAR_API_KEY}" \
  -d '{"query":"mutation { issueRemoveLabel(id: \"ISSUE_UUID\", labelId: \"LABEL_UUID\") { success } }"}'
```

### Label Reference

These are the Dashboard team labels and their UUIDs (populate after creating them in Linear):

```
agent-ready    → UUID: <to-be-filled>    # Trigger: spawns coding agent
agent-working  → UUID: <to-be-filled>    # Agent actively working
ci-failed      → UUID: <to-be-filled>    # CI failure detected
hardware       → UUID: <to-be-filled>    # Needs physical device for QA
needs-spec     → UUID: <to-be-filled>    # Too vague, bounced back
```

**IMPORTANT:** The FIRST thing you do when you start working is: remove `agent-ready`, add `agent-working`, and move the issue to **In Progress**. After opening a PR, move the issue to **In Review**. When the orchestrator tells you the PR is approved and green, remove `agent-working` and move to **In QA**. The LAST thing you do before finishing is confirm labels and state are correct.

### Issue State Transitions

You MUST move the issue through these states at the correct milestones. Use Linear MCP tools (preferred) or the CLI fallback.

**State flow:**
```
Backlog/Todo → In Progress → In Review → In QA → Done
```

**Via Linear MCP (preferred):**
Use the `linear_update_issue` tool to change the issue state:
```
Tool: linear_update_issue
Arguments: { "issueId": "ISSUE_UUID", "stateId": "STATE_UUID" }
```

**Via CLI fallback:**
```bash
# First, find the workflow state ID:
curl -s -X POST https://api.linear.app/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: ${LINEAR_API_KEY}" \
  -d '{"query":"{ workflowStates(filter: { team: { id: { eq: \"TEAM_UUID\" } } }) { nodes { id name type } } }"}' | jq .

# Then update the issue:
curl -s -X POST https://api.linear.app/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: ${LINEAR_API_KEY}" \
  -d '{"query":"mutation { issueUpdate(id: \"ISSUE_UUID\", input: { stateId: \"STATE_UUID\" }) { success } }"}'
```

### State Reference

These are the Dashboard team workflow states (populate UUIDs after checking Linear):

```
Backlog        → UUID: <to-be-filled>
Todo           → UUID: <to-be-filled>
In Progress    → UUID: <to-be-filled>
In Review      → UUID: <to-be-filled>
In QA          → UUID: <to-be-filled>
Done           → UUID: <to-be-filled>
Canceled       → UUID: <to-be-filled>
```

---

## Self-Review Protocol (MANDATORY before opening any PR)

You MUST complete this entire checklist before running `gh pr create`. Do NOT skip steps.

### Step 1: Build Verification
```bash
pnpm install
pnpm build
```
If the build fails, fix every error and re-run until clean. Do not proceed until `pnpm build` exits 0.

### Step 2: Lint & Type Check
```bash
pnpm lint
pnpm typecheck
```
Fix all lint errors and type errors. Do not disable rules or add `@ts-ignore` — fix the actual issue.

### Step 3: Run Existing Tests
```bash
pnpm test
```
If any tests fail, determine whether:
- Your changes broke them → fix your code
- The tests are outdated → update the tests to match new behavior AND verify the new behavior is correct

### Step 4: Diff Review
Run `git diff --staged` (or `git diff` if not yet staged) and review your own changes:
- Are there any debug statements (`console.log`, `debugger`) left in?
- Are there any hardcoded secrets, tokens, or credentials?
- Are there any TODO/FIXME comments that should be resolved before merging?
- Are there any files that shouldn't be committed (`.env`, `node_modules`, build artifacts)?
- Does every function/component you added or modified have clear naming?
- Are there any obvious performance issues (N+1 queries, missing memoization, unbounded loops)?

### Step 5: Commit Hygiene
- Use conventional commits: `feat:`, `fix:`, `chore:`, `refactor:`, `test:`
- Reference the Linear issue in the commit: `feat(DSH-XXX): description`
- Keep commits atomic — one logical change per commit
- Write clear commit messages explaining WHY, not just WHAT

### Step 6: PR Creation
Only after steps 1–5 pass:
```bash
gh pr create --title "feat(DSH-XXX): brief description" --body "..."
```
- Link the Linear issue in the PR body: `Closes DSH-XXX`
- Describe what changed and why
- Note any migration steps or breaking changes
- If UI changed, describe how to verify visually

### Step 7: Post-PR Label Cleanup
After creating the PR:
- Confirm `agent-working` is still present
- Confirm `ci-failed` is NOT present (unless CI is currently failing)
- Add a comment to the Linear issue summarizing what the PR does

---

## Error Fix Loop

When the orchestrator sends you CI failures or review comments:
1. Read the FULL error output — don't skim
2. Identify root cause before writing any fix
3. Fix the root cause, not the symptom
4. If CI failed, add the `ci-failed` label immediately
5. Re-run the full self-review protocol (Steps 1–4)
6. Push and confirm CI is green
7. Remove the `ci-failed` label once CI passes

---

## Code Standards

- TypeScript strict mode — no `any`, use `unknown` + type guards
- Prefer `const` over `let`, never use `var`
- Use `node:` prefix for Node.js builtins
- ESM imports with `.js` extensions
- Functional components with hooks for React
- Supabase edge functions: use Deno.serve pattern
- Error handling: throw typed errors, wrap JSON.parse in try/catch
- Always validate external data (API responses, user input, URL params)

---

## What NOT To Do

- Do NOT disable ESLint rules with inline comments
- Do NOT add `@ts-ignore` or `@ts-expect-error`
- Do NOT skip tests to make CI pass
- Do NOT commit `.env` files or secrets
- Do NOT force-push to shared branches
- Do NOT merge your own PR — the orchestrator or a human will handle that
- Do NOT forget to update labels — label state is how the team tracks agent progress
